use futures::channel::mpsc;
use futures::executor; //standard executors to provide a context for futures and streams
use futures::executor::ThreadPool;
use futures::StreamExt;

fn main() {
    let pool = ThreadPool::new().expect("cannot create pool");
    let (tx, rx) = mpsc::unbounded::<i32>();

    // Create a future by an async block, where async is responsible for an
    // implementation of Future. At this point no executor has been provided
    // to this future, so it will not be running.
    let fut_values = async {
        // Create another async block, again where the Future implementation
        // is generated by async. Since this is inside of a parent async block,
        // it will be provided with the executor of the parent block when the parent
        // block is executed.
        //
        // This executor chaining is done by Future::poll whose second argument
        // is a std::task::Context. This represents our executor, and the Future
        // implemented by this async block can be polled using the parent async
        // block's executor.
        let fut_tx_result = async move {
            (0..=100).for_each(|v| {
                tx.unbounded_send(v).expect("Failed to send");
            })
        };

        // Use the provided thread pool to spawn the generated future
        // responsible for transmission
        pool.spawn_ok(fut_tx_result);

        let fut_rx_values = rx.map(|v| v * 2).collect();

        // Use the executor provided to this async block to wait for the
        // future to complete.
        fut_rx_values.await
    };

    // Actually execute the above future, which will invoke Future::poll and
    // subsequently chain appropriate Future::poll and methods needing executors
    // to drive all futures. Eventually fut_values will be driven to completion.
    let values: Vec<i32> = executor::block_on(fut_values);

    println!("Values={:?}", values);
}


/// Use of LocalPool (M:N) that runs futures on a single thread 
/// the last future holds the receiver end of the channel 
/// we use the LocalPool::run_until(future) to grab the value received form all spawned futures
/// Block_on() won't work here as it calls Thread::park() and resumes thread for poll() once it is awaken; hence execution will stop
#[test]
fn test_local_pool_async() {
    use futures::task::SpawnExt;
    use futures::executor::LocalPool;
    use futures::task::{LocalSpawnExt};

    let (tx, rx) = mpsc::channel(100);
    let mut pool = LocalPool::new();
    
    // Spawn futures against green thread
    for i in 0..50 {
        let mut t = tx.clone();
        pool.spawner()
            .spawn_local(async move {
                print!("s");
                t.start_send(i).expect("msg");
                drop(t);
            })
            .expect("msg");
    }

    let hnd = pool.spawner().spawn_with_handle( async {
    // Spawn future that listens the channel end and collects what was sent
        // drop holding of last sender reference so we channel drops after the last message has been retrieved
        drop(tx);
        rx.inspect(|_| print!("r")).collect::<Vec<_>>().await
    }).unwrap();
    
    println!("{:?}", pool.run_until(hnd));
}

/// Use of TreadPool that runs the futures on their own system thread 
/// The async block contains the logic for spawning all calculations and collect the results; the process is kicked off with the first poll()
/// ThreadPool::spawn_ok() kicks off future polling immediately, hence there is no ThreadPoll::run() method
/// ThreadPool::spawn_with_handle() help us to wait on the last future / thread to collect the results
/// Block_on() works agains the RemoteHandle which is like a pointer to future. Also, since block_on() parks own thread awaiting to be awaked our futures continue processing since they've be spawned() up with their own thread
#[test]
fn test_thread_pool_async_v1() {
    use futures::executor::block_on;

    let (tx, rx) = futures::channel::mpsc::channel(100);
    let pool = futures::executor::ThreadPool::builder()
        // .after_start(|d| println!("after start {d}"))
        // .before_stop(|d| println!("before stop {d}"))
        // .pool_size(10)
        .create()
        .expect("msg");

    // Spawn future on current thread that listens the channel end and collects what was sent
    let hnd = async move {

        // Spawn futures against their own thread; task will poll() immediatelly
        for i in 0..50 {
            let t = tx.clone();
            pool.spawn_ok(async move {
                print!("s");
                std::thread::sleep(std::time::Duration::from_micros( 1 + 1 % 5));
                t.clone().start_send(i).expect("msg");
            })
        }
        drop(tx);
        rx.inspect(|_| print!("r")).collect::<Vec<_>>().await
    };

    // drop holding of last sender reference so we channel drops after the last message has been retrieved
    
    println!("{:?}", block_on(hnd));
}

/// Use of TreadPool that runs the futures on their own system thread 
/// The calcualtion are spawned separately with spawn_ok() outside the async block; hence executing before future is polled
/// ThreadPool::Build() to experiment with pool size; use 1 thread pool to see the interleaving for thread work
/// ThreadPool::spawn_ok() kicks off future polling immediately, hence there is no ThreadPoll::run() method
/// ThreadPool::spawn_with_handle() help us to wait on the last future / thread to collect the results
/// Block_on() works agains the RemoteHandle which is like a pointe to future
#[test]
fn test_thread_pool_async_v2() {
    use futures::executor::block_on;

    let (tx, rx) = futures::channel::mpsc::channel(100);
    let pool = futures::executor::ThreadPool::builder()
        // .after_start(|d| println!("after start {d}"))
        // .before_stop(|d| println!("before stop {d}"))
        // .pool_size(10)
        .create()
        .expect("msg");

    // Spawn futures against their own thread, that poll() immediatelly
    for i in 0..50 {
        let t = tx.clone();
        pool.spawn_ok(async move {
            print!("s");
            std::thread::sleep(std::time::Duration::from_micros( 1 + 1 % 5));
            t.clone().start_send(i).expect("msg");
        })
    }
    drop(tx);

    // Spawn future on current thread that listens the channel end and collects what was sent
    let hnd = async move {
        rx.inspect(|_| print!("r")).collect::<Vec<_>>().await
    };

    // drop holding of last sender reference so we channel drops after the last message has been retrieved
    
    println!("{:?}", block_on(hnd));
}
